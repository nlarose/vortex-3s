#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    leftLineFollower, sensorLineFollower)
#pragma config(Sensor, in2,    centerLineFollower, sensorLineFollower)
#pragma config(Sensor, in3,    rightLineFollower, sensorLineFollower)
#pragma config(Sensor, in6,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  ,               sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorNone)
#pragma config(Sensor, dgtl4,  pinceEncodeurConsigne, sensorQuadEncoder)
#pragma config(Sensor, dgtl6,  Solenoide1,     sensorDigitalOut)
#pragma config(Sensor, dgtl7,  Solenoide2,     sensorDigitalOut)
#pragma config(Sensor, dgtl8,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl11, armEncoder,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  rightIME,       sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  leftIME,        sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_3,  armIME,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftMotor,     tmotorVex393_HBridge, openLoop, reversed, driveLeft, encoderPort, I2C_4)
#pragma config(Motor,  port6,           clawMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           armMotor,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port10,          rightMotor,    tmotorVex393_HBridge, openLoop, driveRight, encoderPort, I2C_3)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define MAX_CLAW_POS (400)
#define MAX_DRIVE (100)
#define MIN_DRIVE (-100)

void controleBras(void)
{
		armControl(armMotor, Btn5U, Btn5D, 75);
		armControl(clawMotor, Btn6U, Btn6D, 75);

}

void initClaw(void)
{
		motor[clawMotor] = -75;
		sleep(1000);
		motor[clawMotor] = 0;
		sleep(500);
		nMotorEncoder[clawMotor] = 0;

}
	int encoderVal = 0;
	int positionDesire = 0;
	int clawEncVal = 0;
	int commandeClaw = 0;

task main()
{
	resetSensor();
	initClaw();
	SensorValue[pinceEncodeurConsigne] = 0;
	repeat (forever) {
		encoderVal = SensorValue[pinceEncodeurConsigne];
		clawEncVal = nMotorEncoder[clawMotor];

		if(vexRT[Btn6U] == 1)           // If button 6U (upper right shoulder button) is pressed:
		{
			SensorValue[Solenoide1] = 1;  // activer switch pneumatique
		}
		else // If button 6U (upper right shoulder button) is  NOT pressed:
		{
			SensorValue[Solenoide1] = 0;  // dessative switch
		}

		positionDesire = encoderVal;
		if (positionDesire < 0)
		{
			positionDesire = 0;
		}
		else if (positionDesire > MAX_CLAW_POS)
		{
			positionDesire = MAX_CLAW_POS;
		}
		if (clawEncVal < MAX_CLAW_POS)
		{
			commandeClaw = (int)(((float)positionDesire - (float)clawEncVal) * 1);
		}
		else
		{
			commandeClaw =0;
		}

		if (commandeClaw > MAX_DRIVE)
		{
			commandeClaw = MAX_DRIVE;
		}
		else if (commandeClaw < MIN_DRIVE)
		{
				commandeClaw = MIN_DRIVE;
		}

		motor[clawMotor] = commandeClaw;
		//nMotorEncoderTarget [clawMotor] = positionDesire;

		//controleBras();
		joystickControl(leftMotor, Ch3, 10);
		joystickControl(rightMotor, Ch2, 10);
	}
}
